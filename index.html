<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Asistente Diario PRO - Versi√≥n Unificada (Cloud + Funciones Avanzadas)</title>
<style>
	/* Dise√±o Base */
	body {	
		font-family: Arial, sans-serif;	
		margin: 20px auto;	
		background: #f4f4f4;	
		max-width: 1200px;	
		padding: 0 20px;	
	}

	h1 { color: #333; }
	.section { margin-bottom: 30px; background: #fff; padding: 20px; border-radius: 8px; }
	input, textarea, select { margin: 5px 0; padding: 8px; width: 100%; border: 1px solid #ccc; border-radius: 4px; }
	
	/* === ESTILOS PARA EL ENCABEZADO Y BOT√ìN SALIR === */
	.header-container {
		display: flex;	
		justify-content: space-between;	
		align-items: center;	
		margin-bottom: 10px;	
	}
	.logout-btn {
		background: #d32f2f; /* Rojo para el bot√≥n de salir */
		font-weight: bold;
		padding: 8px 12px;
	}
	.logout-btn:hover {
		opacity: 0.8;
	}
	/* ======================================================= */

	/* Estilo para el bot√≥n de Google (Login) */
	.google-btn {	
		padding: 10px 15px;	
		margin: 5px 5px 0 0;	
		border: none;	
		border-radius: 5px;	
		cursor: pointer;	
		background: #db4437; /* Rojo de Google */
		color: white;	
		font-weight: bold;
	}
	.google-btn:hover { opacity: 0.9; }
	
	/* Estilo para los botones generales */
	button { padding: 10px 15px; margin: 5px 5px 0 0; border: none; border-radius: 5px; cursor: pointer; background: #1976d2; color: white; }
	button:hover { opacity: 0.9; }
	
	/* MODIFICACI√ìN CLAVE: REGLAS PARA EL SCROLL EN LA LISTA UL */
	ul {	
		list-style-type: none;	
		padding: 0;	
		max-height: 400px; /* Altura m√°xima de la lista */
		overflow-y: auto;	 /* Habilita el scroll vertical */
		border: 1px solid #ccc; /* Borde para delimitar el √°rea con scroll */
		padding-right: 10px; /* Espacio para el scroll */
	}

	li {	
		margin: 5px 0;	
		padding: 10px; /* Aumentado padding para mejor toque en m√≥vil */
		background: #eaeaea;	
		border-radius: 5px;	
		cursor: pointer;	
		white-space: normal;
		transition: background-color 0.3s, box-shadow 0.3s;
	}
	.completed {	
		text-decoration: line-through;	
		color: gray;	
		background: #f1f1f1;	
	}
	.calendar { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; }	
	.day { background: #ddd; padding: 10px; border-radius: 5px; min-height: 60px; }
	
	.current-day {
		background-color: #b0b0b0 !important;
		border: 2px solid #555;
	}
	
	.stats { font-weight: bold; margin-top: 10px; }
	
	.task-buttons {	
		display: flex;	
		gap: 10px;	
		flex-wrap: wrap;	
		margin-top: 10px;	
		align-items: flex-start;
		justify-content: space-between;	
	}
	
	.urgent-tag {
		color: red;
		font-weight: bold;
	}

	/* Estilos para Etiqueta y Fecha lado a lado*/
	.task-inputs-row {
		display: flex;	
		gap: 10px; 	
		margin: 5px 0 10px 0;	
	}

	.task-inputs-row select,
	.task-inputs-row input[type="date"] {
		width: 50%;	
		margin: 0; 	
	}

	/* ESTILOS DEL BANNER DE ALERTA */
	.alert-banner {
		padding: 15px;
		margin-bottom: 20px;
		border: 1px solid transparent;
		border-radius: 4px;
		color: #856404;	
		background-color: #fff3cd;	
		border-color: #ffeeba;	
		font-weight: bold;
		display: flex;
		justify-content: space-between;
		align-items: flex-start;	
		box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	}
	.alert-banner button {
		background: transparent;
		color: #856404;
		border: none;
		padding: 5px 10px;
		cursor: pointer;
		font-weight: bold;
		font-size: 1.2em;
		margin-left: 15px;
		line-height: 1;
	}
	.alert-banner button:hover {
		opacity: 0.7;
	}
	.task-list-summary {
		font-size: 0.9em;
		margin-top: 5px;
		white-space: pre-wrap;	
		font-weight: normal;	
	}

	.tomorrow-task {
		font-weight: bold;
		color: orange;
	}

	/* === ESTILOS PARA EL TIME TRACKING ACTIVO (1.2) === */
	@keyframes pulse-active {
		0% { box-shadow: 0 0 5px rgba(56, 142, 60, 0.4); }
		50% { box-shadow: 0 0 10px rgba(56, 142, 60, 0.8); }
		100% { box-shadow: 0 0 5px rgba(56, 142, 60, 0.4); }
	}
	.task-running {
		background-color: #e8f5e9 !important; /* Verde muy claro */
		border: 2px solid #388e3c; /* Borde verde oscuro */
		animation: pulse-active 2s infinite;
	}
	/* ======================================================= */

	/* === MEDIA QUERIES PARA RESPONSIVIDAD (Paso 2) === */
	@media (max-width: 768px) {
		body {
			padding: 0 10px; /* Reduce padding lateral */
		}
	 	
		/* 1. LAYOUT PRINCIPAL */
		.header-container {
			flex-direction: column; /* Apila el t√≠tulo y el bot√≥n Salir */
			align-items: flex-start;
		}
		.header-container h1 {
			font-size: 1.5em;
		}

		/* 2. TAREAS Y CONTROLES */
		.task-inputs-row {
			flex-direction: column; /* Apila Etiqueta y Fecha */
			gap: 0;
		}
		.task-inputs-row select,
		.task-inputs-row input[type="date"] {
			width: 100%; /* Ocupan todo el ancho */
			margin-bottom: 5px;
		}

		/* 3. BOTONES DE ACCI√ìN */
		.task-buttons {
			flex-direction: column; /* Apila los grupos de botones */
			gap: 15px;	
		}

		/* 4. LISTA DE TAREAS (LI) - Crucial para botones */
		#taskList li > div {
			flex-direction: column; /* Apila el texto y los botones */
			align-items: flex-start;
		}
		#taskList li span {
			margin-bottom: 5px; /* Espacio despu√©s del texto de la tarea */
			display: block;
			width: 100%; /* Asegura que ocupe todo el ancho para el tap */
			cursor: pointer;
		}
		#taskList li > div > div {
			/* Contenedor de botones (Editar, Iniciar/Detener, Eliminar) */
			display: flex;
			flex-wrap: wrap; /* Envuelve los botones si no caben */
			margin-top: 5px;
			width: 100%;
		}
		#taskList li > div > div button {
			margin: 3px 5px 3px 0; /* Espaciado m√°s compacto */
		}
	 	
		/* 5. CALENDARIO */
		.calendar {
			grid-template-columns: repeat(3, 1fr); /* Muestra 3 columnas en lugar de 5 en m√≥vil */
		}
		.day {
			min-height: 80px; /* Aumenta un poco la altura para el tacto */
			padding: 5px;
		}
	 	
		/* 6. BANNER DE ALERTA */
		.alert-banner {
			flex-direction: column;
		}
		.alert-banner button {
			align-self: flex-start; /* Alinea el bot√≥n de cerrar */
			margin-left: 0;
			margin-top: 5px;
		}

		/* 7. FILTROS R√ÅPIDOS y ORDENACI√ìN */
		#filterButtons {
			flex-direction: column;
		}
		#filterButtons button {
			width: 100%;
			margin: 3px 0;
		}
		#sortSelector {
			width: 100% !important;
			max-width: none !important;
		}
	}
</style>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</head>
<body>

<div id="loginSection" class="section" style="display: block;">
	<p>Inicia sesi√≥n con Google para acceder a tu Asistente Diario PRO.</p>
	<button id="google-login-btn" class="google-btn" onclick="signInWithGoogle()">
		<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Google_%22G%22_logo.svg/48px-Google_%22G%22_logo.svg.png" alt="Google Logo" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 8px;">
		Iniciar sesi√≥n con Google
	</button>
	<p id="authMessage" style="color: gray;">Esperando inicio de sesi√≥n...</p>
</div>

<div id="mainContent" style="display: none;">

	<div class="header-container">
		<h1 id="userWelcome">Asistente Diario PRO</h1>
		<button class="logout-btn" onclick="signOutUser()">üëã Cerrar Sesi√≥n</button>
	</div>

	<div id="upcomingTasksBanner" style="display: none;" class="alert-banner">
	</div>
	
	<p id="fecha-hora"></p>

	<div class="section">
		<h2>‚úÖ Tareas</h2>
		<input id="taskInput" placeholder="Escribe una tarea..." type="text"/>
		
		<div class="task-inputs-row">
			<select id="taskTag">
				<option value="">Sin Etiqueta</option>
				<option value="Urgente">Urgente</option>
				<option value="Reuni√≥n">Reuni√≥n</option>
				<option value="Personal">Personal</option>
				<option value="Desarrollo">Desarrollo</option>
				<option value="Otro">Otro</option>
			</select>
			<input id="taskDate" type="date"/>
		</div>
		
		<div class="task-buttons">
			<div style="display: flex; gap: 10px; flex-wrap: wrap;">
				<button id="addTaskBtn" onclick="addTask()">‚ûï Agregar tarea</button>
				<button onclick="clearForm()">üßπ Limpiar formulario</button>
			</div>
			<div style="display: flex; gap: 10px; flex-wrap: wrap;">
				<button onclick="startDictation()">üéôÔ∏è Comenzar dictado</button>
			</div>
		</div>
		
		<p id="recordingTimer" style="display: none;">‚è±Ô∏è Tiempo de grabaci√≥n: 0 segundos</p>
		
		<p id="statusMessage" style="color: blue;">Esperando inicio de sesi√≥n...</p>
		
		<div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
			<label for="sortSelector" style="font-weight: bold; white-space: nowrap;">Ordenar por:</label>
			<select id="sortSelector" style="width: auto; max-width: 200px;" onchange="renderTasks()">
				<option value="default">Fecha de Creaci√≥n (M√°s nuevo primero)</option>
				<option value="dateAsc">Fecha L√≠mite (M√°s cercana primero)</option>
				<option value="dateDesc">Fecha L√≠mite (M√°s lejana primero)</option>
				<option value="tagPriority">Etiqueta (Urgente primero)</option>
			</select>
		</div>

		<div class="task-buttons" id="filterButtons">
			<div style="display: flex; gap: 10px; flex-wrap: wrap;">
				<button onclick="filterTasks('')" id="filter-Todos">
					Mostrar Todos
				</button>
				<button 
					onclick="filterTasks('Urgente')"
					id="filter-Urgente">
					Urgente
				</button>
				<button 
					onclick="filterTasks('Reuni√≥n')"
					id="filter-Reuni√≥n">
					Reuni√≥n
				</button>
				<button 
					onclick="filterTasks('Personal')"
					id="filter-Personal">
					Personal
				</button>
				<button 
					onclick="filterTasks('Desarrollo')"
					id="filter-Desarrollo">
					Desarrollo
				</button>
				<button 
					onclick="filterTasks('Otro')"
					id="filter-Otro">
					Otro
				</button>
			</div>
			<div style="display: flex; gap: 10px; flex-wrap: wrap;">
				<button onclick="clearAllCompletedTasks()" style="background: #e64a19;">‚ùå Eliminar tareas completadas</button>
				<button onclick="generatePDFReport()" style="background: #00796b;">üìÑ Generar Reporte PDF</button>
			</div>
		</div>

		<div class="stats">
			<p>Tareas completadas hoy: <span id="completedToday">0</span></p>
			<p>Tiempo total de seguimiento: <span id="totalTimeTracked">0h 0m</span> (en <span id="tasksWithTimeCount">0</span> tareas)</p>
		</div>
		
		<ul id="taskList">
			</ul>
	</div>

	<div class="section">
		<h2>üìÖ Resumen Semanal</h2>
		<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
			<button onclick="changeMonth(-1)">&#9664; Mes Anterior</button>
			<h3 id="calendarTitle"></h3>
			<button onclick="changeMonth(1)">Mes Siguiente &#9654;</button>
		</div>
		<div id="calendar" class="calendar">
			</div>
	</div>

	<div id="historySection" class="section">
		<h2>üóëÔ∏è Historial de Tareas Completadas (√öltimas 5)</h2>
		<ul id="completedTasksList">
			</ul>
	</div>

</div>

<script>
	// ----------------------------------------------------------------------
	// ‚ö†Ô∏è ‚öôÔ∏è CONFIGURACI√ìN DE FIREBASE (¬°IMPORTANTE!) ‚öôÔ∏è ‚ö†Ô∏è
	// ----------------------------------------------------------------------
	// DEBES REEMPLAZAR LA CONFIGURACI√ìN DE ABAJO CON TUS CREDENCIALES REALES
	// PARA QUE LA APLICACI√ìN PUEDA CONECTARSE.
	const firebaseConfig = {
		// [TUS CREDENCIALES DE FIREBASE AQU√ç]
		// Ejemplo (BORRA ESTO Y USA TUS DATOS):
		// apiKey: "AIzaSyB_...",
		// authDomain: "tu-proyecto.firebaseapp.com",
		// projectId: "tu-proyecto-id",
		// storageBucket: "tu-proyecto-id.appspot.com",
		// messagingSenderId: "...",
		// appId: "..."
	};

	// Inicializar Firebase
	if (!firebase.apps.length) {
		firebase.initializeApp(firebaseConfig);
	}

	const db = firebase.firestore();
	const auth = firebase.auth();
	const tasksCollection = db.collection("tareas_pro");
	
	// Variables globales
	let tasks = [];
	let currentUser = null;
	let editingTaskId = null;
	let currentFilter = '';
	const WEEK_DAYS = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'];
	let currentCalendarDate = new Date(); // Para el calendario
	const TAG_PRIORITY = { 'Urgente': 3, 'Reuni√≥n': 2, 'Personal': 1, 'Desarrollo': 1, 'Otro': 0, '': 0 }; // Para ordenar por prioridad
	
	// Variables del Time Tracker
	let timerUpdateInterval; // El intervalo que se ejecuta cada segundo para actualizar el tiempo en pantalla
	
	// Variables del Dictado de Voz (Restauradas)
	let recordingInterval; 
	let recordingSeconds = 0;
	
	// ----------------------------------------------------------------------
	// üíª ELEMENTOS DOM üíª
	// ----------------------------------------------------------------------
	const loginSection = document.getElementById('loginSection');
	const mainContent = document.getElementById('mainContent');
	const authMessage = document.getElementById('authMessage');
	const statusMessage = document.getElementById('statusMessage');

	// ----------------------------------------------------------------------
	// üíª FUNCIONES AUXILIARES üíª
	// ----------------------------------------------------------------------
	
	/**
	 * Formatea una fecha ISO (YYYY-MM-DD) a un formato legible (DD/MM/YYYY)
	 * @param {string} isoDate La fecha en formato ISO
	 * @returns {string} La fecha en formato DD/MM/YYYY
	 */
	function formatDateToDisplay(isoDate) {
		if (!isoDate) return 'Sin fecha';
		const [year, month, day] = isoDate.split('-');
		return `${day}/${month}/${year}`;
	}
	
	/**
	 * Formatea un n√∫mero de milisegundos a un string de horas, minutos y segundos.
	 * @param {number} ms Milisegundos de tiempo transcurrido.
	 * @returns {string} Tiempo en formato Hh Mm Ss.
	 */
	function formatTime(ms) {
		const totalSeconds = Math.floor(ms / 1000);
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		const seconds = totalSeconds % 60;
		
		let timeString = '';
		if (hours > 0) timeString += `${hours}h `;
		if (minutes > 0 || hours > 0) timeString += `${minutes}m `;
		timeString += `${seconds}s`;
		
		return timeString.trim();
	}
	
	/**
	 * Obtiene la fecha de hoy en formato YYYY-MM-DD para el input[type="date"]
	 */
	function getTodayDateStrForInput() {
		const today = new Date();
		const day = String(today.getDate()).padStart(2, '0');
		const month = String(today.getMonth() + 1).padStart(2, '0'); // Enero es 0
		const year = today.getFullYear();
		return `${year}-${month}-${day}`;
	}
	
	/**
	 * Inicializa el input de fecha a la fecha actual y establece el m√≠nimo.
	 */
	function initializeDateInput() {
		const todayStr = getTodayDateStrForInput();
		const taskDateInput = document.getElementById('taskDate');
		
		// 1. Establece el valor por defecto a la fecha actual
		taskDateInput.value = todayStr;
		
		// 2. Establece la fecha m√≠nima seleccionable a la fecha actual
		taskDateInput.min = todayStr;
	}
	
	// ----------------------------------------------------------------------
	// üíæ FUNCIONES DE DATOS (CLOUD Y LOCAL) üíæ
	// ----------------------------------------------------------------------
	
	/**
	 * Carga los datos de las tareas desde Firestore o Local Storage.
	 */
	async function loadData() {
		if (currentUser) {
			// Carga desde Firestore
			try {
				const doc = await tasksCollection.doc(currentUser.uid).get();
				if (doc.exists) {
					tasks = doc.data().tasks || [];
					tasks = tasks.map(task => {
						// Asegurar que las nuevas propiedades existan para evitar errores
						if (typeof task.elapsedTime === 'undefined') task.elapsedTime = 0;
						if (typeof task.startTime === 'undefined') task.startTime = null;
						return task;
					});
				} else {
					// Si no existe el documento, se inicializa la lista
					tasks = [];
				}
				statusMessage.style.color = 'green';
				statusMessage.innerText = '‚úÖ Tareas cargadas desde la nube.';
			} catch (error) {
				console.error("Error al cargar las tareas desde Firestore:", error);
				statusMessage.style.color = 'red';
				statusMessage.innerText = '‚ùå Error al cargar tareas desde la nube. Revisa la consola.';
			}
		} else {
			// Carga desde Local Storage (fallback o modo no logueado)
			const storedTasks = localStorage.getItem('tasks');
			tasks = storedTasks ? JSON.parse(storedTasks) : [];
			statusMessage.style.color = 'orange';
			statusMessage.innerText = '‚ö†Ô∏è Tareas cargadas desde Local Storage.';
		}
		
		// Despu√©s de cargar, renderizar y actualizar el calendario
		renderTasks();
		renderCalendar();
		updateDateTime();
	}
	
	/**
	 * Guarda los datos de las tareas en Firestore o Local Storage.
	 */
	function saveData() {
		if (currentUser) {
			// Guardar en Firestore
			tasksCollection.doc(currentUser.uid).set({ tasks: tasks })
				.then(() => {
					// console.log("Datos guardados en Firestore.");
				})
				.catch((error) => {
					console.error("Error al guardar en Firestore:", error);
				});
		} else {
			// Guardar en Local Storage
			localStorage.setItem('tasks', JSON.stringify(tasks));
		}
	}
	
	// ----------------------------------------------------------------------
	// ‚è±Ô∏è FUNCIONES DEL TIME TRACKER ‚è±Ô∏è
	// ----------------------------------------------------------------------
	
	/**
	 * Inicia el intervalo de actualizaci√≥n global para los timers de tareas.
	 */
	function startTimerInterval() {
		if (timerUpdateInterval) {
			clearInterval(timerUpdateInterval);
		}
		// Se actualiza el tiempo cada segundo para las tareas en ejecuci√≥n
		timerUpdateInterval = setInterval(() => {
			// Solo renderizamos si hay alguna tarea corriendo
			if (tasks.some(t => t.startTime !== null)) {
				renderTasks(true); // El 'true' indica que es una actualizaci√≥n silenciosa de tiempo
				saveData(); // Guardamos el progreso del tiempo cada segundo
			}
		}, 1000);
	}
	
	/**
	 * Funci√≥n principal para iniciar o detener el cron√≥metro de una tarea.
	 * @param {string} taskId El ID de la tarea
	 */
	function toggleTimer(taskId) {
		const taskIndex = tasks.findIndex(t => t.id === taskId);
		if (taskIndex === -1) return;
		
		const task = tasks[taskIndex];
		const now = Date.now();
		
		if (task.startTime) {
			// 1. DETENER CRON√ìMETRO: Calcular tiempo transcurrido
			const elapsed = now - task.startTime;
			task.elapsedTime = (task.elapsedTime || 0) + elapsed;
			task.startTime = null; // Detener
			statusMessage.style.color = 'gray';
			statusMessage.innerText = `‚è±Ô∏è Cron√≥metro de tarea #${taskIndex + 1} detenido.`;
		} else {
			// 2. INICIAR CRON√ìMETRO:
			// Detener cualquier otra tarea que est√© corriendo
			tasks.forEach(t => {
				if (t.startTime && t.id !== taskId) {
					t.elapsedTime = (t.elapsedTime || 0) + (now - t.startTime);
					t.startTime = null;
				}
			});
			
			// Iniciar la tarea seleccionada
			task.startTime = now;
			statusMessage.style.color = '#388e3c'; // Verde
			statusMessage.innerText = `‚ñ∂Ô∏è Cron√≥metro de tarea #${taskIndex + 1} iniciado.`;
		}
		
		saveData();
		renderTasks();
		startTimerInterval(); // Asegurar que el intervalo est√© corriendo
	}
	
	/**
	 * Calcula el tiempo total invertido en todas las tareas.
	 */
	function calculateTotalTime() {
		let totalMs = 0;
		let tasksWithTime = 0;
		
		tasks.forEach(task => {
			let currentElapsedTime = task.elapsedTime || 0;
			
			// Si la tarea est√° corriendo, a√±ade el tiempo transcurrido desde startTime
			if (task.startTime) {
				const now = Date.now();
				const elapsedSinceStart = now - task.startTime;
				currentElapsedTime += elapsedSinceStart;
			}
			
			totalMs += currentElapsedTime;
			
			if (currentElapsedTime > 0) {
				tasksWithTime++;
			}
		});
		
		document.getElementById('totalTimeTracked').innerText = formatTime(totalMs);
		document.getElementById('tasksWithTimeCount').innerText = tasksWithTime;
	}
	
	// ----------------------------------------------------------------------
	// üí¨ FUNCIONES DEL DICTADO DE VOZ üí¨
	// ----------------------------------------------------------------------

	function startDictation() {
		// Verificar soporte
		if (!('webkitSpeechRecognition' in window)) {
			statusMessage.style.color = 'red';
			statusMessage.innerText = '‚ùå Lo sentimos, tu navegador no soporta Dictado de Voz.';
			return;
		}
		
		// Inicializar reconocimiento
		const recognition = new webkitSpeechRecognition();
		recognition.lang = 'es-ES';
		recognition.continuous = false; // Detener despu√©s de la primera pausa
		recognition.interimResults = false;
		
		// Controlar el estado
		recognition.onstart = function() {
			statusMessage.style.color = '#1976d2'; // Azul
			statusMessage.innerText = 'üéôÔ∏è Escuchando... Di tu tarea.';
			
			// L√≥gica del contador de tiempo (Mantenida, pero oculta)
			document.getElementById('recordingTimer').innerText = "üéôÔ∏è Escuchando...";
			recordingSeconds = 0; // Reiniciar contador
			recordingInterval = setInterval(() => {
				recordingSeconds++;
				document.getElementById('recordingTimer').innerText = `üéôÔ∏è Grabando: ${recordingSeconds} segundos`;
			}, 1000); // Actualiza cada segundo
		};
		
		recognition.onresult = function(event) {
			const transcript = event.results[0][0].transcript;
			document.getElementById('taskInput').value = transcript;
			statusMessage.style.color = 'green';
			statusMessage.innerText = '‚úÖ Dictado finalizado. Texto listo para agregar.';
			
			// L√≥gica del contador de tiempo (Mantenida, pero oculta)
			clearInterval(recordingInterval);
			document.getElementById('recordingTimer').innerText = `‚è±Ô∏è Texto recibido (${recordingSeconds} segundos)`;
		};
		
		recognition.onerror = function(event) {	
			// L√≥gica del contador de tiempo (Mantenida, pero oculta)
			clearInterval(recordingInterval);	
			document.getElementById('recordingTimer').innerText = `‚ùå Error en el dictado: ${event.error}`;
			
			statusMessage.style.color = 'red';
			statusMessage.innerText = `‚ùå Error en el dictado: ${event.error}`;
		};
		
		recognition.onend = function() {	
			// L√≥gica del contador de tiempo (Mantenida, pero oculta)
			clearInterval(recordingInterval);	
			document.getElementById('recordingTimer').innerText = `‚è±Ô∏è Dictado finalizado. ${recordingSeconds} segundos`;
		};
		
		try {
			recognition.start();
		} catch (e) {
			console.error("Error al iniciar el reconocimiento de voz:", e);
			statusMessage.style.color = 'red';
			statusMessage.innerText = '‚ùå Error al intentar iniciar el micr√≥fono. Aseg√∫rate de tener permiso.';
		}
	}

	// ----------------------------------------------------------------------
	// ‚öôÔ∏è FUNCIONES DE MANEJO DE TAREAS (CRUD) ‚öôÔ∏è
	// ----------------------------------------------------------------------
	
	/**
	 * Agrega una nueva tarea.
	 */
	function addTask() {
		const taskInput = document.getElementById('taskInput');
		const taskText = taskInput.value.trim();
		const taskTag = document.getElementById('taskTag').value;
		const taskDate = document.getElementById('taskDate').value;

		if (taskText === '') {
			statusMessage.style.color = 'red';
			statusMessage.innerText = '‚ùå Por favor, escribe una tarea.';
			return;
		}

		const newTask = {
			id: editingTaskId || Date.now().toString(), // Usa el ID de edici√≥n si existe
			text: taskText,
			completed: false,
			date: taskDate,
			tag: taskTag,
			createdAt: Date.now(),
			elapsedTime: 0, // Nuevo campo para el seguimiento de tiempo
			startTime: null // Nuevo campo para la hora de inicio del cron√≥metro
		};

		if (editingTaskId) {
			// Modo edici√≥n
			const index = tasks.findIndex(t => t.id === editingTaskId);
			if (index !== -1) {
				// Mantiene completed, elapsedTime y startTime
				newTask.completed = tasks[index].completed; 
				newTask.elapsedTime = tasks[index].elapsedTime; 
				newTask.startTime = tasks[index].startTime; 
				tasks[index] = newTask;
			}
			editingTaskId = null;
			document.getElementById('addTaskBtn').innerText = '‚ûï Agregar tarea';
			statusMessage.style.color = 'green';
			statusMessage.innerText = '‚úÖ Tarea editada correctamente.';
		} else {
			// Modo nueva tarea
			tasks.push(newTask);
			statusMessage.style.color = 'green';
			statusMessage.innerText = '‚úÖ Tarea agregada correctamente.';
		}
		
		clearForm(false); // Limpia solo el formulario, no la fecha
		saveData();
		renderTasks();
		renderCalendar();
	}
	
	/**
	 * Limpia los campos del formulario.
	 * @param {boolean} clearDate Si es true, limpia tambi√©n la fecha (default: false).
	 */
	function clearForm(clearDate = false) {
		document.getElementById('taskInput').value = '';
		document.getElementById('taskTag').value = '';
		if (clearDate) {
			// Reinicia la fecha al valor por defecto
			initializeDateInput(); 
		}
		editingTaskId = null;
		document.getElementById('addTaskBtn').innerText = '‚ûï Agregar tarea';
		statusMessage.style.color = 'blue';
		statusMessage.innerText = 'Esperando inicio de sesi√≥n...';
	}
	
	/**
	 * Carga una tarea en el formulario para editarla.
	 * @param {string} taskId El ID de la tarea a editar.
	 */
	function editTask(taskId) {
		const task = tasks.find(t => t.id === taskId);
		if (!task) return;

		document.getElementById('taskInput').value = task.text;
		document.getElementById('taskTag').value = task.tag;
		document.getElementById('taskDate').value = task.date;
		
		editingTaskId = taskId;
		document.getElementById('addTaskBtn').innerText = 'üíæ Guardar edici√≥n';
		statusMessage.style.color = 'orange';
		statusMessage.innerText = `‚úèÔ∏è Editando tarea: ${task.text.substring(0, 30)}...`;
	}

	/**
	 * Elimina una tarea.
	 * @param {string} taskId El ID de la tarea a eliminar.
	 */
	function deleteTask(taskId) {
		if (confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
			tasks = tasks.filter(t => t.id !== taskId);
			saveData();
			renderTasks();
			renderCalendar();
			statusMessage.style.color = 'red';
			statusMessage.innerText = 'üóëÔ∏è Tarea eliminada.';
			
			// Si la tarea eliminada estaba en edici√≥n, limpiar el formulario
			if (editingTaskId === taskId) {
				clearForm();
			}
		}
	}
	
	/**
	 * Marca una tarea como completada o incompleta.
	 * @param {string} taskId El ID de la tarea a modificar.
	 */
	function toggleComplete(taskId) {
		const task = tasks.find(t => t.id === taskId);
		if (!task) return;

		task.completed = !task.completed;
		
		// L√≥gica del Time Tracker: Si se completa una tarea, detener su cron√≥metro
		if (task.completed && task.startTime !== null) {
			const now = Date.now();
			const elapsed = now - task.startTime;
			task.elapsedTime = (task.elapsedTime || 0) + elapsed;
			task.startTime = null; // Detener
		}

		// Si se descompleta, no pasa nada con el timer, se mantiene detenido.

		saveData();
		renderTasks();
		renderCalendar();
		renderHistory();

		statusMessage.style.color = 'purple';
		statusMessage.innerText = task.completed ? '‚úÖ Tarea completada. ¬°Bien hecho!' : 'üîÑ Tarea marcada como pendiente.';
	}
	
	/**
	 * Filtra la lista de tareas.
	 * @param {string} filterTag La etiqueta por la que se desea filtrar.
	 */
	function filterTasks(filterTag) {
		currentFilter = filterTag;
		renderTasks();
		
		// Resaltar el bot√≥n activo
		document.querySelectorAll('#filterButtons button').forEach(btn => {
			btn.style.background = '#1976d2'; // Color por defecto
		});
		
		const activeBtn = document.getElementById(`filter-${filterTag || 'Todos'}`);
		if (activeBtn) {
			activeBtn.style.background = '#0d47a1'; // Color de activo
		}
	}
	
	/**
	 * Elimina permanentemente todas las tareas que est√°n marcadas como completadas.
	 */
	function clearAllCompletedTasks() {
		if (confirm('¬øEst√°s seguro de que quieres eliminar PERMANENTEMENTE todas las tareas completadas? Esta acci√≥n no se puede deshacer.')) {
			// 1. Respaldar las tareas completadas eliminadas (√∫ltimas 5)
			const completedTasks = tasks.filter(t => t.completed)
				.sort((a, b) => b.createdAt - a.createdAt); // Ordena por m√°s reciente primero

			const tasksToBackup = completedTasks.slice(0, 5).map(t => ({
				text: t.text,
				completedAt: new Date().toLocaleString()
			}));
			
			// Limpia el respaldo antiguo antes de guardar el nuevo
			cleanUpCompletedTasksBackup(); 
			localStorage.setItem('completedTasksBackup', JSON.stringify(tasksToBackup));
			renderHistory();

			// 2. Eliminar de la lista principal
			tasks = tasks.filter(t => !t.completed);
			saveData();
			renderTasks();
			renderCalendar();
			statusMessage.style.color = '#e64a19'; // Naranja oscuro
			statusMessage.innerText = 'üóëÔ∏è Todas las tareas completadas han sido eliminadas y las √∫ltimas 5 respaldadas.';
		}
	}

	/**
	 * Genera un reporte PDF de las tareas pendientes.
	 */
	function generatePDFReport() {
		const { jsPDF } = window.jspdf;
		const doc = new jsPDF();
		let y = 10;
		const lineGap = 7;
		
		doc.setFontSize(16);
		doc.text("Asistente Diario PRO - Reporte de Tareas Pendientes", 10, y);
		y += lineGap * 2;
		
		doc.setFontSize(12);
		const pendingTasks = tasks.filter(t => !t.completed);
		
		if (pendingTasks.length === 0) {
			doc.text("No hay tareas pendientes.", 10, y);
		} else {
			pendingTasks.forEach((task, index) => {
				const tag = task.tag ? `[${task.tag}] ` : '';
				const date = task.date ? ` (${formatDateToDisplay(task.date)})` : '';
				const time = task.elapsedTime ? ` ‚è±Ô∏è ${formatTime(task.elapsedTime)}` : '';
				
				const text = `${index + 1}. ${tag}${task.text}${date}${time}`;
				
				// Salto de p√°gina si es necesario
				if (y > 280) { 
					doc.addPage();
					y = 10;
				}
				
				doc.text(text, 10, y);
				y += lineGap;
			});
		}
		
		doc.save('reporte_tareas_pendientes.pdf');
		statusMessage.style.color = '#00796b';
		statusMessage.innerText = 'üìÑ Reporte PDF generado.';
	}

	// ----------------------------------------------------------------------
	// üé® FUNCIONES DE RENDERIZADO üé®
	// ----------------------------------------------------------------------

	/**
	 * Renderiza la lista de tareas en el DOM.
	 * @param {boolean} silentUpdate Si es true, solo actualiza la hora (para el cron√≥metro).
	 */
	function renderTasks(silentUpdate = false) {
		// 1. Aplicar la l√≥gica de ordenaci√≥n
		const sortValue = document.getElementById('sortSelector').value;
		let sortedTasks = [...tasks]; 

		if (sortValue === 'dateAsc') {
			sortedTasks.sort((a, b) => {
				if (a.completed !== b.completed) return a.completed ? 1 : -1;
				if (!a.date) return 1; 
				if (!b.date) return -1;
				return new Date(a.date) - new Date(b.date);
			});
		} else if (sortValue === 'dateDesc') {
			sortedTasks.sort((a, b) => {
				if (a.completed !== b.completed) return a.completed ? 1 : -1;
				if (!a.date) return 1; 
				if (!b.date) return -1;
				return new Date(b.date) - new Date(a.date);
			});
		} else if (sortValue === 'tagPriority') {
			sortedTasks.sort((a, b) => {
				if (a.completed !== b.completed) return a.completed ? 1 : -1;
				// Ordena por prioridad (Urgente > Reuni√≥n > Personal/Desarrollo/Otro)
				return TAG_PRIORITY[b.tag || ''] - TAG_PRIORITY[a.tag || '']; 
			});
		} else { // default: por fecha de creaci√≥n descendente
			sortedTasks.sort((a, b) => {
				if (a.completed !== b.completed) return a.completed ? 1 : -1;
				return b.createdAt - a.createdAt;
			});
		}
		
		// 2. Aplicar el filtro por etiqueta
		const filteredTasks = sortedTasks.filter(t => 
			!currentFilter || t.tag === currentFilter
		);

		const taskList = document.getElementById('taskList');
		
		// Si es una actualizaci√≥n silenciosa, solo actualizamos los elementos de tiempo
		if (silentUpdate) {
			calculateTotalTime();
			filteredTasks.forEach(task => {
				const timeElement = document.getElementById(`time-${task.id}`);
				if (timeElement) {
					let totalMs = task.elapsedTime || 0;
					// Si est√° corriendo, sumar el tiempo desde el inicio
					if (task.startTime) {
						totalMs += (Date.now() - task.startTime);
					}
					timeElement.innerText = `‚è±Ô∏è ${formatTime(totalMs)}`;
				}
			});
			return; // Finalizar la funci√≥n para la actualizaci√≥n silenciosa
		}


		// 3. Renderizado completo
		taskList.innerHTML = '';
		const todayStr = getTodayDateStrForInput();
		let completedTodayCount = 0;
		const tasksForBanner = [];

		filteredTasks.forEach(task => {
			if (task.completed) {
				const completedDateStr = new Date(task.createdAt).toISOString().split('T')[0];
				if (completedDateStr === todayStr) {
					completedTodayCount++;
				}
			}

			// L√≥gica para el banner de tareas pr√≥ximas
			if (!task.completed && task.date && task.date >= todayStr) {
				const diffTime = new Date(task.date).getTime() - new Date(todayStr).getTime();
				const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
				
				if (diffDays >= 0 && diffDays <= 7) {
					tasksForBanner.push({
						text: task.text,
						date: task.date,
						days: diffDays,
						tag: task.tag
					});
				}
			}

			// Crear el elemento LI
			const li = document.createElement('li');
			li.className = task.completed ? 'completed' : '';
			// Si la tarea est√° corriendo, a√±ade la clase de animaci√≥n
			if (task.startTime) {
				li.classList.add('task-running');
			}
			
			// 3.1 Contenido de la tarea (flexbox)
			const taskContentDiv = document.createElement('div');
			taskContentDiv.style.display = 'flex';
			taskContentDiv.style.justifyContent = 'space-between';
			taskContentDiv.style.alignItems = 'center';

			// 3.2 Texto, Etiqueta, Fecha y Timer (lado izquierdo)
			const infoSpan = document.createElement('span');
			let tagHtml = task.tag ? `<span class="urgent-tag">[${task.tag}]</span> ` : '';
			let dateHtml = task.date ? `<small style="display: block; color: #555;">Fecha l√≠mite: ${formatDateToDisplay(task.date)}</small>` : '';
			
			// Calcular y mostrar tiempo
			let totalMs = task.elapsedTime || 0;
			if (task.startTime) {
				totalMs += (Date.now() - task.startTime);
			}
			const timeSpan = `<span id="time-${task.id}" style="font-weight: bold; color: #333;">‚è±Ô∏è ${formatTime(totalMs)}</span>`;


			infoSpan.innerHTML = `${tagHtml}${task.text}${dateHtml}${timeSpan}`;
			infoSpan.onclick = () => toggleComplete(task.id);
			
			// 3.3 Botones de acci√≥n (lado derecho)
			const buttonDiv = document.createElement('div');
			
			const editBtn = document.createElement('button');
			editBtn.innerText = '‚úèÔ∏è Editar';
			editBtn.style.background = '#f9a825';
			editBtn.onclick = (e) => { e.stopPropagation(); editTask(task.id); }; // Detener propagaci√≥n
			
			const deleteBtn = document.createElement('button');
			deleteBtn.innerText = 'üóëÔ∏è Eliminar';
			deleteBtn.style.background = '#d32f2f';
			deleteBtn.onclick = (e) => { e.stopPropagation(); deleteTask(task.id); };
			
			const timerBtn = document.createElement('button');
			// Cambia el texto del bot√≥n seg√∫n si est√° corriendo o no
			timerBtn.innerText = task.startTime ? '‚ùö‚ùö Detener' : '‚ñ∂Ô∏è Iniciar'; 
			timerBtn.style.background = task.startTime ? '#ef6c00' : '#388e3c'; // Naranja/Verde
			timerBtn.onclick = (e) => { e.stopPropagation(); toggleTimer(task.id); };


			// Agrega los botones al div
			buttonDiv.appendChild(editBtn);
			buttonDiv.appendChild(timerBtn);
			buttonDiv.appendChild(deleteBtn);
			
			// 3.4 Ensamblar el LI
			taskContentDiv.appendChild(infoSpan);
			taskContentDiv.appendChild(buttonDiv);
			li.appendChild(taskContentDiv);
			taskList.appendChild(li);
		});

		// 4. Actualizar estad√≠sticas
		document.getElementById('completedToday').innerText = completedTodayCount;
		calculateTotalTime();

		// 5. Renderizar el Banner de Tareas Pr√≥ximas
		renderUpcomingTasksBanner(tasksForBanner);
	}
	
	/**
	 * Renderiza el historial de las √∫ltimas 5 tareas completadas del respaldo local.
	 */
	function renderHistory() {
		const historyList = document.getElementById('completedTasksList');
		historyList.innerHTML = '';
		
		const storedBackup = localStorage.getItem('completedTasksBackup');
		const backupTasks = storedBackup ? JSON.parse(storedBackup) : [];
		
		if (backupTasks.length === 0) {
			historyList.innerHTML = '<li>No hay historial de tareas completadas eliminadas.</li>';
			return;
		}
		
		backupTasks.forEach(task => {
			const li = document.createElement('li');
			li.className = 'completed';
			li.style.textDecoration = 'none'; // Quitar tachado en el historial para m√°s claridad
			li.innerHTML = `
				${task.text}
				<small style="display: block; color: #888;">Eliminada el: ${task.completedAt}</small>
			`;
			historyList.appendChild(li);
		});
	}

	/**
	 * Mantiene solo las √∫ltimas 5 tareas en el respaldo local.
	 */
	function cleanUpCompletedTasksBackup() {
		const storedBackup = localStorage.getItem('completedTasksBackup');
		if (storedBackup) {
			let backupTasks = JSON.parse(storedBackup);
			// Asegurar que solo queden las √∫ltimas 5
			if (backupTasks.length > 5) {
				backupTasks = backupTasks.slice(0, 5);
				localStorage.setItem('completedTasksBackup', JSON.stringify(backupTasks));
			}
		}
	}

	/**
	 * Muestra el banner con un resumen de las tareas pr√≥ximas.
	 * @param {Array<object>} tasksData Array de tareas pr√≥ximas.
	 */
	function renderUpcomingTasksBanner(tasksData) {
		const banner = document.getElementById('upcomingTasksBanner');
		const todayStr = getTodayDateStrForInput();
		
		if (tasksData.length === 0) {
			banner.style.display = 'none';
			return;
		}

		tasksData.sort((a, b) => new Date(a.date) - new Date(b.date));

		let summary = '';
		tasksData.forEach(t => {
			let dateText;
			if (t.date === todayStr) {
				dateText = '¬°HOY!';
			} else if (t.days === 1) {
				dateText = 'Ma√±ana';
			} else {
				dateText = `en ${t.days} d√≠as (${formatDateToDisplay(t.date)})`;
			}
			
			summary += `\n- ${t.text} (${t.tag || 'Sin Etiqueta'}) - ${dateText}`;
		});
		
		banner.innerHTML = `
			<div>
				üîî **TAREAS PR√ìXIMAS (7 D√çAS)**
				<pre class="task-list-summary">${summary}</pre>
			</div>
			<button onclick="document.getElementById('upcomingTasksBanner').style.display='none'">‚úñÔ∏è</button>
		`;
		banner.style.display = 'flex';
	}
	
	// ----------------------------------------------------------------------
	// üóìÔ∏è FUNCIONES DEL CALENDARIO üóìÔ∏è
	// ----------------------------------------------------------------------

	/**
	 * Renderiza el calendario mensual.
	 */
	function renderCalendar() {
		const year = currentCalendarDate.getFullYear();
		const month = currentCalendarDate.getMonth();
		const calendarTitle = document.getElementById('calendarTitle');
		calendarTitle.innerText = `${currentCalendarDate.toLocaleString('es-ES', { month: 'long', year: 'numeric' })}`;
		
		const calendar = document.getElementById('calendar');
		calendar.innerHTML = ''; // Limpiar
		
		// D√≠as de la semana
		WEEK_DAYS.forEach(day => {
			const header = document.createElement('div');
			header.innerText = day;
			header.style.fontWeight = 'bold';
			header.style.textAlign = 'center';
			calendar.appendChild(header);
		});
		
		const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0 (Dom) - 6 (S√°b)
		const daysInMonth = new Date(year, month + 1, 0).getDate();
		const today = getTodayDateStrForInput();

		// Rellenar espacios vac√≠os al inicio
		for (let i = 0; i < firstDayOfMonth; i++) {
			calendar.innerHTML += '<div class="day" style="background: none; border: none;"></div>';
		}
		
		// D√≠as del mes
		for (let day = 1; day <= daysInMonth; day++) {
			const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
			
			// Contar tareas para este d√≠a
			const tasksForDay = tasks.filter(t => t.date === dateStr && !t.completed);
			const completedForDay = tasks.filter(t => t.date === dateStr && t.completed).length;
			
			const dayDiv = document.createElement('div');
			dayDiv.className = 'day';
			dayDiv.dataset.date = dateStr;
			dayDiv.onclick = () => document.getElementById('taskDate').value = dateStr; // Rellenar input al hacer clic
			
			if (dateStr === today) {
				dayDiv.classList.add('current-day');
			}
			
			let content = `<strong>${day}</strong>`;
			
			if (tasksForDay.length > 0) {
				const urgentTasks = tasksForDay.filter(t => t.tag === 'Urgente').length;
				let color = '#333';
				if (urgentTasks > 0) {
					color = 'red';
				} else if (tasksForDay.length > 0) {
					color = '#1976d2';
				}
				
				content += `<p style="margin: 5px 0 0 0; color: ${color}; font-weight: bold; font-size: 0.8em;">${tasksForDay.length} Tarea(s)</p>`;
			}
			
			if (completedForDay > 0) {
				content += `<p style="margin: 0; color: green; font-size: 0.7em;">${completedForDay} Compl.</p>`;
			}

			dayDiv.innerHTML = content;
			calendar.appendChild(dayDiv);
		}
	}
	
	/**
	 * Cambia el mes visualizado en el calendario.
	 * @param {number} offset 1 para siguiente mes, -1 para mes anterior.
	 */
	function changeMonth(offset) {
		currentCalendarDate.setMonth(currentCalendarDate.getMonth() + offset);
		renderCalendar();
	}


	// ----------------------------------------------------------------------
	// üë§ FUNCIONES DE AUTENTICACI√ìN üë§
	// ----------------------------------------------------------------------

	/**
	 * Inicia sesi√≥n con Google.
	 */
	function signInWithGoogle() {
		const provider = new firebase.auth.GoogleAuthProvider();
		auth.signInWithPopup(provider)
			.then((result) => {
				// El observador onAuthStateChanged maneja la actualizaci√≥n de la UI
			})
			.catch((error) => {
				console.error("Error de autenticaci√≥n de Google:", error);
				authMessage.style.color = 'red';
				authMessage.innerText = `‚ùå Error al iniciar sesi√≥n: ${error.message}`;
			});
	}

	/**
	 * Cierra la sesi√≥n del usuario.
	 */
	function signOutUser() {
		auth.signOut()
			.then(() => {
				// El observador onAuthStateChanged maneja la actualizaci√≥n de la UI
			})
			.catch((error) => {
				console.error("Error al cerrar sesi√≥n:", error);
			});
	}

	// Observador de estado de autenticaci√≥n
	auth.onAuthStateChanged(user => {
		currentUser = user;
		if (user) {
			// Usuario logueado
			loginSection.style.display = 'none';
			mainContent.style.display = 'block';
			document.getElementById('userWelcome').innerText = `Asistente Diario PRO (${user.displayName})`;
			loadData();
			startTimerInterval(); // Iniciar el intervalo global
		} else {
			// Usuario desconectado
			currentUser = null;
			loginSection.style.display = 'block';
			mainContent.style.display = 'none';
			authMessage.style.color = 'gray';
			authMessage.innerText = 'Esperando inicio de sesi√≥n...';
			tasks = [];
			renderTasks(); // Limpia la lista de tareas
			
			// Si el usuario cierra sesi√≥n, cargar datos de Local Storage como fallback
			loadData(); 
			
			// Limpiar el intervalo del cron√≥metro
			if (timerUpdateInterval) {
				clearInterval(timerUpdateInterval);
			}
		}
	});

	// ----------------------------------------------------------------------
	// üöÄ INICIALIZACI√ìN üöÄ
	// ----------------------------------------------------------------------

	/**
	 * Muestra la fecha y hora actualizadas.
	 */
	function updateDateTime() {
		const now = new Date();
		document.getElementById('fecha-hora').innerText = now.toLocaleString('es-ES', {
			weekday: 'long', 
			year: 'numeric', 
			month: 'long', 
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit',
			second: '2-digit'
		});
	}

	// Llamadas iniciales
	initializeDateInput();
	renderHistory(); // Cargar historial al inicio
	
	// Actualizar fecha y hora cada segundo
	setInterval(updateDateTime, 1000); 

	// La carga de datos y el renderizado se manejan dentro de auth.onAuthStateChanged
	// para asegurar que se use el UID correcto o el Local Storage.
	
</script>

</body>
</html>
