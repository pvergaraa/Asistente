<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Asistente Diario PRO - Versi√≥n Unificada (Cloud + Funciones Avanzadas)</title>
<style>
    /* Dise√±o Base */
    body { 
        font-family: Arial, sans-serif; 
        margin: 20px auto; 
        background: #f4f4f4; 
        max-width: 1200px; 
        padding: 0 20px; 
    }
    
    h1 { color: #333; }
    .section { margin-bottom: 30px; background: #fff; padding: 20px; border-radius: 8px; }
    input, textarea, select { margin: 5px 0; padding: 8px; width: 100%; border: 1px solid #ccc; border-radius: 4px; }
    
    /* === ESTILOS PARA EL ENCABEZADO Y BOT√ìN SALIR === */
    .header-container {
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 10px; 
    }
    .logout-btn {
        background: #d32f2f; /* Rojo para el bot√≥n de salir */
        font-weight: bold;
        padding: 8px 12px;
    }
    .logout-btn:hover {
        opacity: 0.8;
    }
    /* ======================================================= */

    /* Estilo para el bot√≥n de Google (Login) */
    .google-btn { 
        padding: 10px 15px; 
        margin: 5px 5px 0 0; 
        border: none; 
        border-radius: 5px; 
        cursor: pointer; 
        background: #db4437; /* Rojo de Google */
        color: white; 
        font-weight: bold;
    }
    .google-btn:hover { opacity: 0.9; }
    
    /* Estilo para los botones generales */
    button { padding: 10px 15px; margin: 5px 5px 0 0; border: none; border-radius: 5px; cursor: pointer; background: #1976d2; color: white; }
    button:hover { opacity: 0.9; }
    
    /* MODIFICACI√ìN CLAVE: REGLAS PARA EL SCROLL EN LA LISTA UL */
    ul { 
        list-style-type: none; 
        padding: 0; 
        max-height: 400px; /* Altura m√°xima de la lista */
        overflow-y: auto;  /* Habilita el scroll vertical */
        border: 1px solid #ccc; /* Borde para delimitar el √°rea con scroll */
        padding-right: 10px; /* Espacio para el scroll */
    }

    li { 
        margin: 5px 0; 
        padding: 10px; /* Aumentado padding para mejor toque en m√≥vil */
        background: #eaeaea; 
        border-radius: 5px; 
        cursor: pointer; 
        white-space: normal;
        transition: background-color 0.3s, box-shadow 0.3s;
    }
    
    /* === NUEVOS ESTILOS PARA DRAG AND DROP === */
    li.draggable {
        cursor: grab; /* Cursor para indicar arrastre */
    }
    
    li.dragging {
        opacity: 0.5;
        border: 2px dashed #333;
        background: #e0f7fa;
    }
    
    .completed { text-decoration: line-through; color: gray; background: #f1f1f1; }
    
    .calendar { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; } 
    .day { background: #ddd; padding: 10px; border-radius: 5px; min-height: 60px; }
    
    .current-day {
        background-color: #b0b0b0 !important;
        border: 2px solid #555;
    }
    
    .stats { font-weight: bold; margin-top: 10px; }
    
    .task-buttons { 
        display: flex; 
        gap: 10px; 
        flex-wrap: wrap; 
        margin-top: 10px; 
        align-items: flex-start;
        justify-content: space-between; 
    }
    
    .urgent-tag {
        color: red;
        font-weight: bold;
    }

    /* Estilos para Etiqueta y Fecha lado a lado*/
    .task-inputs-row {
        display: flex; 
        gap: 10px;    
        margin: 5px 0 10px 0; 
    }

    .task-inputs-row select,
    .task-inputs-row input[type="date"] {
        width: 50%; 
        margin: 0;  
    }

    /* ESTILOS DEL BANNER DE ALERTA */
    .alert-banner {
        padding: 15px;
        margin-bottom: 20px;
        border: 1px solid transparent;
        border-radius: 4px;
        color: #856404; 
        background-color: #fff3cd; 
        border-color: #ffeeba; 
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: flex-start; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .alert-banner button {
        background: transparent;
        color: #856404;
        border: none;
        padding: 5px 10px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.2em;
        margin-left: 15px;
        line-height: 1;
    }
    .alert-banner button:hover {
        opacity: 0.7;
    }
    .task-list-summary {
        font-size: 0.9em;
        margin-top: 5px;
        white-space: pre-wrap; 
        font-weight: normal; 
    }

    .tomorrow-task {
        font-weight: bold;
        color: orange;
    }
    
    /* Estilos para Time Tracking activo (1.2) */
    @keyframes pulse-active {
        0% { box-shadow: 0 0 5px rgba(56, 142, 60, 0.4); }
        50% { box-shadow: 0 0 10px rgba(56, 142, 60, 0.8); }
        100% { box-shadow: 0 0 5px rgba(56, 142, 60, 0.4); }
    }
    .task-running {
        background-color: #e8f5e9 !important; /* Verde muy claro */
        border: 2px solid #388e3c; /* Borde verde oscuro */
        animation: pulse-active 2s infinite;
    }
    /* ======================================================= */

</style>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.9.0/firebase-auth-compat.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</head>
<body>
    <div id="loginSection" class="section" style="max-width: 400px; margin: 50px auto; display: block;">
        <h2>üîí Iniciar Sesi√≥n</h2>
        <p>Usa tu cuenta de Google para acceder a tus tareas sincronizadas.</p>
        
        <button onclick="handleLogin()" class="google-btn">
            üöÄ Iniciar Sesi√≥n con Google
        </button>
        
        <p id="authMessage" style="color:red; margin-top:10px;"></p>
    </div>
    
    <div id="mainContent" style="display: none;">
    
        <div class="header-container">
            <h1>üóìÔ∏è Asistente Diario PRO - PVergaraA</h1>
            <button onclick="logout()" class="logout-btn">
                üö™ Salir
            </button> 
        </div>

        <div id="upcomingTasksBanner" style="display: none;" class="alert-banner">
        </div>
        
        <p id="fecha-hora"></p>

        <div class="section">
            <h2>‚úÖ Tareas</h2>
            <input id="taskInput" placeholder="Escribe una tarea..." type="text"/>
            
            <div class="task-inputs-row">
                <select id="taskTag">
                    <option value="">Etiqueta</option>
                    <option value="Urgente">Urgente</option>
                    <option value="Reuni√≥n">Reuni√≥n</option>
                    <option value="Importante">Importante</option>
                    <option value="Pendiente">Pendiente</option>
                </select>
                <input id="taskDate" type="date"/> 
            </div>
            
            <div class="task-buttons">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="exportTasks()">Exportar tareas</button>
                    <button onclick="openBackupWindow()" style="background:#ff9800">üìÇ Respaldo completadas</button> 
                    <button id="deleteBtn" style="background:#d32f2f" onclick="deleteCompletedTasks()">üóëÔ∏è Borrar completadas</button> 
                </div>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="addTask()">Agregar tarea</button>
                    <button onclick="startDictation()">üéôÔ∏è Comenzar dictado</button>
                </div>
            </div>
            
            <p id="recordingTimer" style="margin-top: 10px; text-align: right;">‚è±Ô∏è Tiempo de grabaci√≥n: 0 segundos</p>
            <p id="statusMessage" style="color: blue;">Esperando inicio de sesi√≥n...</p>

            <ul id="taskList"></ul>
            <p class="stats" id="taskStats"></p>
        </div>

        <div class="section">
            <h2>üìÖ Calendario de tareas</h2>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <button onclick="changeMonth(-1)" style="background: #6c757d;">&lt; Mes Anterior</button>
                <h3 id="currentMonthDisplay" style="margin: 0;"></h3>
                <button onclick="changeMonth(1)" style="background: #6c757d;">Mes Siguiente &gt;</button>
            </div>
            <div class="calendar" id="calendarView"></div>
        </div>
        
        <section id="buscador" class="section">
            <h2>Buscar tareas</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input
                type="text"
                id="searchInput"
                placeholder="Escribe para buscar..."
                style="flex-grow: 1;"
                />
                <button
                id="searchBtn"
                >
                Buscar
                </button>
                <button
                id="clearSearchBtn"
                style="background:#6c757d"
                >
                Limpiar
                </button>
            </div>
            <div id="searchResults" class="mt-4"></div>
        </section>
    
    </div>

<script>
    // ----------------------------------------------------------------------
    // ‚öôÔ∏è CONFIGURACI√ìN E INICIALIZACI√ìN DE FIREBASE (TUS DATOS REALES) ‚öôÔ∏è
    // ----------------------------------------------------------------------
    
    // ** IMPORTANTE: REEMPLAZA ESTO CON TUS CREDENCIALES REALES DE FIREBASE **
    const firebaseConfig = {
        apiKey: "AIzaSyAh1g7i3vI37nSQYkUi1gSKstRvLIrCVOY",
        authDomain: "asistenteweb-d1a36.firebaseapp.com",
        projectId: "asistenteweb-d1a36",
        storageBucket: "asistenteweb-d1a36.firebasestorage.app",
        messagingSenderId: "300972571463",
        appId: "1:300972571463:web:b2259fb2eac4b7bae12a62"
    };

    // Colecci√≥n y Documentos Fijos para todas las tareas
    const COLLECTION_NAME = "users";
    const DOCUMENT_ID = "asistente_master_tasks"; // Tareas principales
    const BACKUP_DOCUMENT_ID = "asistente_backup_tasks"; // Tareas de respaldo

    // Inicializar Firebase con el SDK de compatibilidad (V8 style)
    const app = firebase.initializeApp(firebaseConfig);
    const db = app.firestore(); 
    const auth = app.auth(); 

    // Variables globales
    let tasks = []; // Tareas activas
    let completedTasksBackup = []; // Tareas de respaldo
    let timerUpdateInterval;
    let currentCalendarDate = new Date(); 
    let draggedElement = null; // Para Drag and Drop


    // Elementos DOM
    const loginSection = document.getElementById('loginSection');
    const mainContent = document.getElementById('mainContent');
    const authMessage = document.getElementById('authMessage');
    const statusMessage = document.getElementById('statusMessage');


    // ----------------------------------------------------------------------
    // üíª FUNCIONES AUXILIARES üíª
    // ----------------------------------------------------------------------
    
    // NUEVA FUNCI√ìN: Genera un ID √∫nico para cada tarea
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
    }
    
    function formatDateToDisplay(dateStr) {
        if (!dateStr || dateStr.length !== 10) return 'Sin fecha';
        const parts = dateStr.split('-'); // [YYYY, MM, DD]
        if (parts.length === 3) {
            return `${parts[2]}-${parts[1]}-${parts[0]}`; // DD-MM-YYYY
        }
        return dateStr;
    }

    // Obtiene la fecha de hoy en formato YYYY-MM-DD para el input[type="date"]
    function getTodayDateStrForInput() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function formatTime(ms) {
        if (ms === 0 || typeof ms !== 'number') return "00:00:00";
        const totalSeconds = Math.floor(ms / 1000);
        const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
        const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    }

    function getTomorrowDateStr() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        const year = tomorrow.getFullYear();
        const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
        const day = String(tomorrow.getDate()).padStart(2, '0');
        
        return { 
            internal: `${year}-${month}-${day}`, 
            display: `${day}-${month}-${year}` 
        };
    }
    
    function mostrarFechaHora() {
        const ahora = new Date();
        const opcionesFecha = { year: 'numeric', month: '2-digit', day: '2-digit' };
        const fecha = ahora.toLocaleDateString('es-ES', opcionesFecha); // DD/MM/YYYY
        const diaSemanaOpciones = { weekday: 'long' };
        const diaSemana = ahora.toLocaleDateString('es-ES', diaSemanaOpciones);
        const hora = ahora.toLocaleTimeString('es-ES');
        const fechaFormateada = fecha.replace(/\//g, '-'); 
        document.getElementById("fecha-hora").innerHTML = `${diaSemana}, ${fechaFormateada} - ${hora}`;
    }
    mostrarFechaHora();
    setInterval(mostrarFechaHora, 1000);

    // ----------------------------------------------------------------------
    // üîí FUNCIONES DE AUTENTICACI√ìN Y CONTROL DE VISTA üîí
    // ----------------------------------------------------------------------

    function handleLogin() {
        const provider = new firebase.auth.GoogleAuthProvider();
        auth.signInWithPopup(provider)
            .catch((error) => {
                authMessage.innerText = `Error de ingreso con Google: ${error.message}`;
            });
    }

    function logout() {
        auth.signOut().then(() => {
            console.log("Sesi√≥n cerrada.");
        }).catch((error) => {
            console.error("Error al cerrar sesi√≥n: ", error);
        });
    }

    auth.onAuthStateChanged(user => {
        if (user) {
            loginSection.style.display = 'none';
            mainContent.style.display = 'block';
            authMessage.innerText = '';
            loadDataFromCloud(); // Cargar Tareas y Respaldo
            startTimerInterval(); 
        } else {
            loginSection.style.display = 'block'; 
            mainContent.style.display = 'none';
            tasks = [];
            completedTasksBackup = [];
            if (timerUpdateInterval) { 
                clearInterval(timerUpdateInterval); 
            }
            renderTasks();
            renderCalendar();
            document.getElementById('upcomingTasksBanner').style.display='none';
            statusMessage.innerText = "Esperando inicio de sesi√≥n...";
        }
    });

    // ----------------------------------------------------------------------
    // ‚òÅÔ∏è FUNCIONES DE SINCRONIZACI√ìN EN LA NUBE CON FIREBASE ‚òÅÔ∏è
    // ----------------------------------------------------------------------

    async function saveData() {
        if (!auth.currentUser) {
            statusMessage.innerText = "üö® Error: Debes iniciar sesi√≥n para guardar.";
            return;
        }
        
        try {
            statusMessage.innerText = "Guardando...";
            // Guardar Tareas Principales
            await db.collection(COLLECTION_NAME).doc(DOCUMENT_ID).set({ tasks });
            // Guardar Tareas de Respaldo
            await db.collection(COLLECTION_NAME).doc(BACKUP_DOCUMENT_ID).set({ completedTasksBackup });

            console.log("Datos guardados en Firebase.");
            statusMessage.innerText = "Guardado en la nube.";
        } catch (e) {
            console.error("Error al guardar en la nube: ", e);
            statusMessage.innerText = `üö® Error al guardar: ${e.code || e.message}`;
        }
    }

    async function loadDataFromCloud() {
        if (!auth.currentUser) {
            return;
        }
        
        try {
            statusMessage.innerText = "Cargando...";
            
            // Cargar Tareas Principales
            const docSnap = await db.collection(COLLECTION_NAME).doc(DOCUMENT_ID).get();
            tasks = docSnap.exists ? docSnap.data().tasks || [] : []; 

            // Cargar Tareas de Respaldo
            const backupSnap = await db.collection(COLLECTION_NAME).doc(BACKUP_DOCUMENT_ID).get();
            completedTasksBackup = backupSnap.exists ? backupSnap.data().completedTasksBackup || [] : []; 
            
            cleanOldBackups(); // Limpiar respaldos al cargar
            statusMessage.innerText = "Cargado desde la nube.";

        } catch (e) {
            console.error("Error al cargar desde la nube: ", e);
            tasks = [];
            completedTasksBackup = [];
            statusMessage.innerText = `üö® Error de conexi√≥n/reglas de Firebase: ${e.code || e.message}.`;
        }
        
        // CORRECCI√ìN CR√çTICA: Asegurar que todas las tareas tengan un ID √∫nico
        tasks = tasks.map(t => ({ 
            ...t, 
            id: t.id || generateId() 
        }));

        renderTasks();
        renderCalendar();
        checkUpcomingTasks(); 
    }
    
    // ----------------------------------------------------------------------
    // ‚è±Ô∏è FUNCIONES DEL TIME TRACKER ‚è±Ô∏è
    // ----------------------------------------------------------------------

    // MODIFICADO: Ahora usa taskId
    function toggleTimer(taskId) {
        const task = tasks.find(t => t.id === taskId);
        if (!task) return;

        const now = Date.now();

        // Inicializar si no existen
        if (typeof task.elapsedTime === 'undefined') {
             task.elapsedTime = 0;
             task.startTime = null;
        }
        if (typeof task.startTime === 'undefined') task.startTime = null;


        if (task.startTime === null) {
            // INICIAR: Guardar el tiempo actual
            task.startTime = now;
        } else {
            // DETENER: Calcular y acumular el tiempo transcurrido
            const duration = now - task.startTime;
            task.elapsedTime = (task.elapsedTime || 0) + duration;
            task.startTime = null; // Reiniciar el contador de inicio
        }

        saveData();
        renderTasks();
    }

    function startTimerInterval() {
        if (timerUpdateInterval) {
            clearInterval(timerUpdateInterval);
        }
        if (auth.currentUser) {
            // Se actualiza cada segundo para que el cron√≥metro se vea progresar
            timerUpdateInterval = setInterval(renderTasks, 1000); 
        }
    }


    // ----------------------------------------------------------------------
    // ---- L√ìGICA DE LA APLICACI√ìN (MODIFICADA PARA USAR ID) ----
    // ----------------------------------------------------------------------

    // MODIFICADO: Usa generateId()
    function addTask(text = null) {
        const taskInput = document.getElementById('taskInput');
        const taskDateInput = document.getElementById('taskDate'); 
        
        const taskText = text || taskInput.value;
        const tag = document.getElementById('taskTag').value;
        const date = taskDateInput.value; 
        
        if (taskText.trim()) {
            tasks.push({ 
                id: generateId(), // **CR√çTICO: ID √öNICO**
                text: taskText.trim(), 
                tag, 
                date, 
                done: false,
                startTime: null,      
                elapsedTime: 0        
            });
            saveData();
            
            if (!text) { 
                 taskInput.value = '';
                 document.getElementById('taskTag').value = ''; // Limpiar etiqueta
            }
            
            // Restablece el campo de fecha a la fecha actual despu√©s de agregar la tarea
            initializeDateInput(); 
            
            renderTasks();
            renderCalendar();
            checkUpcomingTasks();
        }
    }

    // MODIFICADO: Ahora usa taskId
    function toggleTask(taskId) {
        const task = tasks.find(t => t.id === taskId);
        if (!task) return;

        task.done = !task.done;

        // Si se completa, detener el cron√≥metro y acumular tiempo
        if (task.done && task.startTime !== null) {
            const now = Date.now();
            const duration = now - task.startTime;
            task.elapsedTime = (task.elapsedTime || 0) + duration;
            task.startTime = null;
        }
        
        if (!task.done) {
            task.startTime = null; 
        }

        saveData();
        renderTasks();
        renderCalendar();
        checkUpcomingTasks();
    }

    // MODIFICADO: Mover tareas completadas a la lista de respaldo antes de eliminarlas
    function deleteCompletedTasks() {
        if (!auth.currentUser) return;

        const tasksToBackup = tasks
            .filter(t => t.done)
            .map(t => ({
                ...t,
                // Usar ID existente (t.id) o generar uno si no existe (por seguridad)
                id: t.id || Date.now() + Math.random(), 
                deletedDate: new Date().toISOString().slice(0, 10) // Fecha de borrado
            }));

        if (tasksToBackup.length === 0) {
            alert("No hay tareas completadas para borrar.");
            return;
        }

        // 1. Agregar las tareas a la lista de respaldo
        completedTasksBackup.push(...tasksToBackup);
        
        // 2. Filtrar las tareas que NO est√°n completadas
        tasks = tasks.filter(t => !t.done);
        
        // 3. Guardar ambas listas
        saveData(); 
        
        // 4. Limpiar los respaldos viejos
        cleanOldBackups();

        // 5. Renderizar
        renderTasks();
        renderCalendar(); 
        checkUpcomingTasks(); 
    }

    // MODIFICADA: Ahora adjunta eventos de doble click y ID al span
    function renderTasks() {
        const list = document.getElementById('taskList');
        list.innerHTML = '';
        
        const totalTasks = tasks.length;

        // 1. Separar tareas pendientes y completadas.
        let pendingTasks = tasks.filter(t => !t.done);
        let completedTasks = tasks.filter(t => t.done);
        
        // 2. TAREAS PENDIENTES: Se muestran en el orden exacto del array (para Drag & Drop).
        // 3. TAREAS COMPLETADAS: Se ordenan por m√°s recientes primero y se a√±aden al final.
        completedTasks.sort((a, b) => b.id.localeCompare(a.id)); 
        
        const sortedTasks = [...pendingTasks, ...completedTasks];
        
        sortedTasks.forEach((task, i) => {
            const taskId = task.id; // **USAR ID**
            const taskNumber = i + 1; 

            const li = document.createElement('li');
            li.setAttribute('data-task-id', taskId); // ID para mapear en el drop

            let classList = task.done ? 'completed' : '';
            
            // ----------------------------------------------------
            // L√ìGICA DE DRAG & DROP y CLASES
            // ----------------------------------------------------
            if (!task.done) {
                // Tareas pendientes son arrastrables
                li.setAttribute('draggable', 'true');
                li.classList.add('draggable');
                li.addEventListener('dragstart', handleDragStart);
                li.addEventListener('dragover', handleDragOver);
                li.addEventListener('drop', handleDrop);
                li.addEventListener('dragenter', (e) => e.preventDefault()); // Permite drop
                
                // Si est√° corriendo el cron√≥metro
                if (task.startTime !== null) { 
                    classList += ' task-running'; 
                }
            }

            if (classList.trim().length > 0) {
                li.className = classList.trim(); 
            }
            
            const tagText = task.tag || 'Sin etiqueta';
            let styledTag = tagText;

            if (tagText === 'Urgente') {
                styledTag = `<span class="urgent-tag">${tagText}</span>`;
            }

            const displayDate = formatDateToDisplay(task.date);

            // ----------------------------------------------------
            // ‚è±Ô∏è L√ìGICA DE TIEMPO Y BOT√ìN 
            // ----------------------------------------------------
            if (typeof task.elapsedTime === 'undefined') task.elapsedTime = 0;
            if (typeof task.startTime === 'undefined') task.startTime = null;

            let currentElapsedTime = task.elapsedTime || 0; 
            let timerButtonHTML = '';
            let timerDisplay = '';
            
            if (!task.done) {
                if (task.startTime !== null) {
                    currentElapsedTime += (Date.now() - task.startTime);
                    
                    timerButtonHTML = `
                        <button 
                            style="background: #d32f2f; margin: 0; padding: 5px 10px; font-weight: bold;" 
                            onclick="event.stopPropagation(); toggleTimer('${taskId}')">
                            ‚èπÔ∏è Detener
                        </button>
                    `;
                } else {
                    timerButtonHTML = `
                        <button 
                            style="background: #388e3c; margin: 0; padding: 5px 10px;" 
                            onclick="event.stopPropagation(); toggleTimer('${taskId}')">
                            ‚ñ∂Ô∏è Iniciar
                        </button>
                    `;
                }
                timerDisplay = ` | Tiempo: <strong>${formatTime(currentElapsedTime)}</strong>`;
            } else {
                 timerDisplay = ` | Tiempo Total: <strong>${formatTime(currentElapsedTime)}</strong>`;
                 timerButtonHTML = ``; 
            }
            
            const taskDisplayContent = `${taskNumber}. ${task.text} (${styledTag}) - ${displayDate}${timerDisplay}`;
            const mainSpanId = `task-text-${taskId}`;
            
            // Estructura del LI (El span principal recibe el ID para adjuntar eventos)
            li.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="${mainSpanId}" style="flex-grow: 1; user-select: none;"> 
                        ${taskDisplayContent}
                    </span>
                    ${timerButtonHTML}
                </div>
            `;
            
            list.appendChild(li);
            
            // ----------------------------------------------------------------------
            // ‚úèÔ∏è POST-RENDER: ATTACH EVENTS (Toggle and Inline Edit) ‚úèÔ∏è
            // ----------------------------------------------------------------------
            const mainSpan = document.getElementById(mainSpanId);

            if (!task.done) {
                // Tarea Pendiente: Toggle con un click, Editar con doble click
                mainSpan.onclick = () => toggleTask(taskId); 
                mainSpan.ondblclick = (e) => { 
                    e.stopPropagation(); 
                    // Pasamos el texto *puro* de la tarea (task.text) y el elemento SPAN
                    editTaskInline(taskId, task.text, mainSpan); 
                };
            } else {
                // Tarea Completada: Solo Toggle
                mainSpan.onclick = () => toggleTask(taskId);
            }
            // ----------------------------------------------------------------------
        });
        
        const completed = tasks.filter(t => t.done).length;
        document.getElementById('taskStats').innerText = `Completadas: ${completed} / Pendientes: ${totalTasks - completed}`;
    }
    
    // ----------------------------------------------------------------------
    // ‚úèÔ∏è FUNCIONES DE EDICI√ìN EN L√çNEA (Inline Editing) ‚úèÔ∏è
    // ----------------------------------------------------------------------

    /**
     * Reemplaza la tarea en la lista por un textarea editable.
     * @param {string} taskId - El ID √∫nico de la tarea.
     * @param {string} currentText - El texto actual de la tarea.
     * @param {HTMLElement} targetSpan - El elemento span que se hizo doble clic.
     */
    function editTaskInline(taskId, currentText, targetSpan) {
        const task = tasks.find(t => t.id === taskId);
        if (!task || task.done) return;
        
        // 1. Crear el textarea
        const textarea = document.createElement('textarea');
        textarea.value = currentText; 
        textarea.style.width = '100%'; 
        textarea.style.minHeight = '50px';
        textarea.style.margin = '0';
        textarea.style.resize = 'vertical';
        textarea.style.border = '2px solid #1976d2'; 
        textarea.style.borderRadius = '4px';
        textarea.style.boxSizing = 'border-box'; 

        // 2. Crear un nuevo LI temporal para la edici√≥n
        const originalLi = targetSpan.closest('li');
        const editLi = document.createElement('li');
        editLi.style.background = '#e3f2fd'; // Azul claro para indicar edici√≥n
        editLi.style.padding = '10px';
        editLi.style.cursor = 'default';
        editLi.classList.add('editing'); // Clase para evitar Drag/Drop

        editLi.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <p style="font-size: 0.9em; margin: 0; color: #666;">üìù Editando: (Presiona Enter o Sal de aqu√≠ para guardar)</p>
            </div>
        `;
        editLi.appendChild(textarea);
        
        // 3. Reemplazar el LI original por el LI de edici√≥n temporal
        originalLi.replaceWith(editLi);

        // 4. Evento para guardar al perder el foco (blur)
        textarea.onblur = () => {
             // Peque√±o retardo para asegurar que el blur no se active inmediatamente
            setTimeout(() => saveTaskEdit(taskId, textarea.value.trim()), 100);
        };
        
        // 5. Evento para guardar al presionar ENTER
        textarea.onkeypress = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); 
                textarea.blur(); // Ejecuta el onblur para guardar
            }
        };

        textarea.focus();
        textarea.select(); // Selecciona todo el texto para f√°cil reemplazo.
    }

    /**
     * Guarda el nuevo texto de la tarea en el array y en Firebase.
     * @param {string} taskId - El ID √∫nico de la tarea.
     * @param {string} newText - El nuevo texto de la tarea.
     */
    function saveTaskEdit(taskId, newText) {
        const task = tasks.find(t => t.id === taskId);
        
        if (!task) return;

        if (newText) {
            task.text = newText;
            saveData(); 
        } else {
             alert("La tarea no puede quedar vac√≠a. No se guardaron los cambios.");
        }
        
        // Siempre re-renderizar para restaurar la vista original de la lista
        renderTasks(); 
    }
    
    // ----------------------------------------------------------------------
    // ‚úã FUNCIONES DE DRAG AND DROP (ARRRASTRAR Y SOLTAR) ‚úã
    // ----------------------------------------------------------------------

    function handleDragStart(e) {
        // Solo permitir arrastrar tareas pendientes
        if (e.target.classList.contains('completed')) {
            e.preventDefault();
            return;
        }
        
        draggedElement = e.target;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', draggedElement.innerHTML);
        
        // Peque√±o retardo para que la clase no se aplique al drag image
        setTimeout(() => {
            draggedElement.classList.add('dragging');
        }, 0);
    }

    function handleDragOver(e) {
        // Evita el comportamiento por defecto (que es 'no permitir drop')
        e.preventDefault(); 
        
        const target = e.target.closest('li.draggable');
        if (target && target !== draggedElement) {
            // L√≥gica para determinar si colocar antes o despu√©s
            const targetRect = target.getBoundingClientRect();
            const offset = targetRect.y + targetRect.height / 2;

            if (e.clientY > offset) {
                // Si el cursor est√° en la mitad inferior, intenta ponerlo DESPU√âS
                if (target.nextSibling !== draggedElement) {
                    document.getElementById('taskList').insertBefore(draggedElement, target.nextSibling);
                }
            } else {
                // Si el cursor est√° en la mitad superior, intenta ponerlo ANTES
                if (target !== draggedElement.nextSibling) {
                    document.getElementById('taskList').insertBefore(draggedElement, target);
                }
            }
        }
    }

    function handleDrop(e) {
        e.preventDefault();
        
        if (draggedElement) {
            draggedElement.classList.remove('dragging');
            
            // Si el elemento soltado es una tarea pendiente
            if (!draggedElement.classList.contains('completed')) {
                 reorderTasksInArray();
            }
        }
    }
    
    // NUEVA FUNCI√ìN: Actualiza el array de 'tasks' seg√∫n el orden del DOM
    function reorderTasksInArray() {
        const taskList = document.getElementById('taskList');
        const listItems = Array.from(taskList.children);
        
        // 1. Obtener el orden de los IDs de las tareas PENDIENTES
        const newPendingOrderIds = listItems
            .filter(li => !li.classList.contains('completed'))
            .map(li => li.getAttribute('data-task-id'));

        // 2. Obtener las tareas completadas
        const completedTasks = tasks.filter(t => t.done);
        
        // 3. Crear el nuevo array de tareas: Pendientes (en el nuevo orden) + Completadas (al final)
        const newPendingTasks = newPendingOrderIds.map(id => tasks.find(t => t.id === id));
        
        // 4. Asignar el nuevo orden al array global y guardar
        tasks = [...newPendingTasks, ...completedTasks];
        saveData();
        
        // 5. Volver a renderizar para actualizar los n√∫meros de tarea (1, 2, 3...)
        renderTasks();
    }


    // ----------------------------------------------------------------------
    // [SECCI√ìN OMITIDA POR BREVEDAD: Contiene funciones auxiliares no modificadas como exportTasks, dictation, backup, calendar, y search]
    // ----------------------------------------------------------------------

    // ---- EXPORTAR TAREAS (A PDF con jsPDF) ----
    function exportTasks() {
        if (tasks.length === 0) {
            alert("No hay tareas para exportar.");
            return;
        }
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        let y = 10; 
        const lineHeight = 7;
        const pageWidth = doc.internal.pageSize.getWidth();
        const margin = 10;
        
        const title = "REPORTE DE TAREAS ASISTENTE DIARIO PRO";
        doc.setFontSize(16);
        doc.text(title, pageWidth / 2, y, { align: 'center' });
        y += lineHeight * 2;
        
        doc.setFontSize(10);
        doc.setFont(doc.getFont().fontName, 'normal');

        // Usa el array 'tasks' directamente (que ahora est√° en el orden manual/deseado)
        tasks.forEach((t, index) => {
            const timeWorked = t.elapsedTime ? ` | Tiempo: ${formatTime(t.elapsedTime)}` : '';
            const status = t.done ? '[COMPLETADA]' : '[PENDIENTE]';
            const tag = t.tag ? ` | Etiqueta: ${t.tag}` : '';
            const displayDate = formatDateToDisplay(t.date);
            const date = t.date ? ` | Fecha: ${displayDate}` : '';
            
            const color = t.done ? [128, 128, 128] : [0, 0, 0]; 
            doc.setTextColor(...color);

            const textLine = `${index + 1}. ${status} ${t.text}${tag}${date}${timeWorked}`;
            
            if (y + lineHeight > doc.internal.pageSize.getHeight() - margin) {
                doc.addPage();
                y = margin; 
            }
            
            doc.text(textLine, margin, y);
            y += lineHeight;
        });

        doc.save("Reporte_Tareas_PRO_" + new Date().toISOString().slice(0, 10) + ".pdf");
    }

    // ---- DICTADO ----
    let recordingInterval;
    let recordingSeconds = 0;

    function startDictation() {
        if (!('SpeechRecognition' in window) && !('webkitSpeechRecognition' in window)) {
            alert('El reconocimiento de voz no est√° soportado por tu navegador. Prueba con Chrome o Edge.');
            return;
        }
        
        const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'es-ES';
        recognition.interimResults = false; 
        
        recognition.onstart = function() {
            recordingSeconds = 0;
            document.getElementById('recordingTimer').innerText = "üéôÔ∏è ESCUCHANDO... (0 segundos)";
            recordingInterval = setInterval(() => {
                recordingSeconds++;
                document.getElementById('recordingTimer').innerText = `üéôÔ∏è ESCUCHANDO... (${recordingSeconds} segundos)`;
            }, 1000);
        };
        
        recognition.onresult = function(event) {
            const transcript = event.results[0][0].transcript;
            addTask("üó£Ô∏è TAREA DICTADA: " + transcript); 
        };
        
        recognition.onerror = function(event) { 
            clearInterval(recordingInterval); 
            document.getElementById('recordingTimer').innerText = `‚ùå Error en el dictado: ${event.error}`;
        };
        
        recognition.onend = function() { 
            clearInterval(recordingInterval); 
            document.getElementById('recordingTimer').innerText = `‚è±Ô∏è Dictado finalizado. ${recordingSeconds} segundos`;
        };

        try {
             recognition.start();
        } catch(e) {
             clearInterval(recordingInterval); 
             document.getElementById('recordingTimer').innerText = "Error al iniciar el dictado. Es posible que ya est√© activo.";
        }
    }
    
    // ----------------------------------------------------------------------
    // üìÇ FUNCIONES DE RESPALDO Y RESTAURACI√ìN (Integradas con Firebase) üìÇ
    // ----------------------------------------------------------------------
    
    function cleanOldBackups() {
        if (!auth.currentUser) return;

        const oneMonthAgo = new Date();
        oneMonthAgo.setDate(oneMonthAgo.getDate() - 30); 

        const initialLength = completedTasksBackup.length;
        
        completedTasksBackup = completedTasksBackup.filter(t => {
            if (!t.deletedDate) return true; // Mantener si no tiene fecha de borrado
            const deleted = new Date(t.deletedDate);
            return deleted >= oneMonthAgo; 
        });

        if (completedTasksBackup.length !== initialLength) {
            // Guardar en la nube si se hizo una limpieza
            saveData(); 
            console.log(`Se eliminaron ${initialLength - completedTasksBackup.length} tareas antiguas del respaldo.`);
        }
    }
    
    function restoreTask(taskId) {
        if (!auth.currentUser) return;

        const taskToRestore = completedTasksBackup.find(t => t.id == taskId); 
        
        if (taskToRestore) {
            // Quitar la tarea del respaldo
            completedTasksBackup = completedTasksBackup.filter(t => t.id != taskId);
            
            // Agregar a la lista principal como pendiente, con NUEVO ID
            tasks.push({ 
                id: generateId(),
                text: taskToRestore.text, 
                tag: taskToRestore.tag, 
                date: taskToRestore.date, 
                done: false,
                startTime: null,
                elapsedTime: 0
            });
            saveData();
            
            // Refrescar vistas
            renderTasks();
            renderCalendar();
            checkUpcomingTasks();
            alert(`Tarea restaurada: ${taskToRestore.text}`);
            
            // Cerrar y reabrir la ventana de respaldo
            const backupWindow = window.open("", "TasksBackupWindow");
            if (backupWindow) {
                backupWindow.close();
                openBackupWindow();
            }
        }
    }

    function openBackupWindow() {
        cleanOldBackups(); 
        
        const backupWindow = window.open("", "TasksBackupWindow", "width=600,height=500,scrollbars=yes");
        
        if (!backupWindow) {
            alert("El bloqueo de pop-ups impidi√≥ abrir la ventana de respaldo.");
            return;
        }

        backupWindow.document.write(`
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <title>Tareas Completadas Respaldadas</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; }
                    h1 { color: #333; }
                    ul { list-style-type: none; padding: 0; }
                    li { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; }
                    .restore-btn { padding: 5px 10px; border: none; border-radius: 5px; cursor: pointer; background: #4CAF50; color: white; }
                    .restore-btn:hover { opacity: 0.9; }
                    .deleted-date { font-size: 0.8em; color: #777; margin-top: 5px; }
                    .time-tracker-info { font-size: 0.8em; color: #007bff; margin-top: 5px; }
                </style>
            </head>
            <body>
                <h1>Tareas Completadas Respaldadas (${completedTasksBackup.length})</h1>
                <p>Las tareas en esta lista tienen una antig√ºedad menor a 1 mes y se pueden restaurar a la lista principal de pendientes.</p>
                <ul>
        `);

        if (completedTasksBackup.length === 0) {
            backupWindow.document.write('<li>No hay tareas respaldadas actualmente.</li>');
        } else {
            completedTasksBackup.forEach(task => {
                const displayDate = formatDateToDisplay(task.date);
                const deletedDate = task.deletedDate ? formatDateToDisplay(task.deletedDate) : 'N/A';
                const timeTrackerInfo = task.elapsedTime ? 
                    `<div class="time-tracker-info">Tiempo trabajado: ${formatTime(task.elapsedTime)}</div>` : '';
                
                // IMPORTANTE: Se usa el ID de la tarea de respaldo
                backupWindow.document.write(`
                    <li>
                        <div>
                            <strong>${task.text}</strong> (${task.tag || 'Sin etiqueta'}) 
                            <br/>Fecha original: ${displayDate}
                            <div class="deleted-date">Borrada: ${deletedDate}</div>
                            ${timeTrackerInfo}
                        </div>
                        <button class="restore-btn" onclick="opener.restoreTask('${task.id}')">
                            Restaurar
                        </button>
                    </li>
                `);
            });
        }

        backupWindow.document.write(`
                </ul>
                <button onclick="window.close()" class="restore-btn" style="background: #f44336; margin-top: 20px;">Cerrar Ventana</button>
            </body>
            </html>
        `);
        backupWindow.document.close();
        backupWindow.focus();
    }

    // ----------------------------------------------------------------------
    // üîî FUNCIONES PARA ALERTA (Banner) üîî
    // ----------------------------------------------------------------------

    function checkUpcomingTasks() {
        if (!auth.currentUser) return;

        const today = new Date();
        const todayInternalDateStr = today.toISOString().slice(0, 10);
        const tomorrowDates = getTomorrowDateStr();
        
        const banner = document.getElementById('upcomingTasksBanner');
        
        const todayTasks = tasks.filter(t => t.date === todayInternalDateStr && !t.done);
        const tomorrowTasks = tasks.filter(t => t.date === tomorrowDates.internal && !t.done);
        
        const allUpcomingTasks = [...todayTasks, ...tomorrowTasks];

        if (allUpcomingTasks.length > 0) {
            let title = '';
            let listContent = '';
            
            if (todayTasks.length > 0 && tomorrowTasks.length > 0) {
                title = `Tienes **${allUpcomingTasks.length} tarea(s)** pendiente(s) entre hoy y ma√±ana.`;
            } else if (todayTasks.length > 0) {
                title = `Tienes **${todayTasks.length} tarea(s)** pendiente(s) para **HOY** (${formatDateToDisplay(todayInternalDateStr)}).`;
            } else if (tomorrowTasks.length > 0) {
                title = `Tienes **${tomorrowTasks.length} tarea(s)** pendiente(s) para **MA√ëANA** (${tomorrowDates.display}).`;
            }
            
            const summaryTasks = [...todayTasks, ...tomorrowTasks].map(t => {
                const dateLabel = t.date === todayInternalDateStr ? '(HOY)' : '(MA√ëANA)';
                return `- ${t.text} (${t.tag || 'Sin etiqueta'}) ${dateLabel}`;
            });
            listContent = summaryTasks.join('\n');
            
            banner.innerHTML = `
                <div>
                    <strong>üö® ALERTA:</strong> ${title.replace(/\*\*/g, '<strong>').replace(/\*\*/g, '</strong>')}
                    <div class="task-list-summary">${listContent}</div>
                </div>
                <button onclick="document.getElementById('upcomingTasksBanner').style.display='none'">‚úñ</button>
            `;
            banner.style.display = 'flex'; 
        } else {
            banner.style.display = 'none'; 
        }
    }


    // ----------------------------------------------------------------------
    // üìÖ FUNCIONES DEL CALENDARIO (Navegable) üìÖ
    // ----------------------------------------------------------------------
    
    function changeMonth(offset) {
        currentCalendarDate.setMonth(currentCalendarDate.getMonth() + offset);
        renderCalendar(); 
    }

    function renderCalendar() {
        const targetDate = currentCalendarDate; 
        const calendar = document.getElementById('calendarView');
        const monthDisplay = document.getElementById('currentMonthDisplay');
        
        calendar.innerHTML = '';

        const year = targetDate.getFullYear();
        const month = targetDate.getMonth();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
        monthDisplay.innerText = `${monthNames[month]} ${year}`;
        
        const today = new Date();
        const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        
        const tomorrowStr = getTomorrowDateStr().internal; 

        const dayNames = ['Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes'];
        
        calendar.style.gridTemplateColumns = 'repeat(5, 1fr)';
        
        dayNames.forEach(name => {
            const header = document.createElement('div');
            header.className = 'day-header';
            header.style.fontWeight = 'bold';
            header.style.textAlign = 'center';
            header.innerText = name;
            calendar.appendChild(header);
        });

        let firstDayOfMonth = new Date(year, month, 1).getDay();
        if (firstDayOfMonth === 0) firstDayOfMonth = 7; 

        if (firstDayOfMonth >= 1 && firstDayOfMonth <= 5) {
            for (let i = 1; i < firstDayOfMonth; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'day';
                emptyDay.style.background = '#f4f4f4';
                emptyDay.style.border = 'none';
                calendar.appendChild(emptyDay);
            }
        }
        
        // COMBINAR TAREAS ACTIVAS Y RESPALDADAS PARA EL CALENDARIO
        const allCalendarTasks = [...tasks, ...completedTasksBackup];
        
        for (let d = 1; d <= daysInMonth; d++) {
            const dateObj = new Date(year, month, d);
            let dayOfWeek = dateObj.getDay();
            if (dayOfWeek === 6 || dayOfWeek === 0) {
                continue;
            }

            const monthStr = String(month + 1).padStart(2, '0');
            const dayStr = String(d).padStart(2, '0');
            const dateStr = `${year}-${monthStr}-${dayStr}`; 
            
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day';

            if (dateStr === todayStr) {
                dayDiv.classList.add('current-day');
            }

            const dayNameIndex = dayOfWeek - 1; 
            const dayNameShort = dayNames[dayNameIndex].substring(0, 3);
            dayDiv.innerHTML = `<strong>${dayNameShort} ${d}</strong><br>`;
            
            allCalendarTasks.filter(t => t.date === dateStr).forEach(t => {
                const p = document.createElement('p');
                p.innerText = t.text;
                p.style.fontSize = '12px';
                // La tarea se considera 'hecha' si est√° en la lista principal y 'done: true', o si tiene un 'id' (est√° en respaldo)
                const isDone = t.done || t.id !== undefined; 
                
                p.style.color = isDone ? 'gray' : '#333';
                p.style.textDecoration = isDone ? 'line-through' : 'none';
                
                if (dateStr === tomorrowStr && !isDone) {
                    p.innerHTML += ' <span class="tomorrow-task">(Ma√±ana)</span>';
                }
                
                dayDiv.appendChild(p);
            });
            calendar.appendChild(dayDiv);
        }
    }


    // ----------------------------------------------------------------------
    // üîç FUNCIONES DE B√öSQUEDA üîç
    // ----------------------------------------------------------------------
    
    function searchItems() {
        const query = document.getElementById('searchInput').value.toLowerCase();
        const results = document.getElementById('searchResults');
        results.innerHTML = '';
        
        if (query.trim() === "") {
            results.innerHTML = '<p>Por favor, ingrese un t√©rmino de b√∫squeda.</p>';
            return;
        }

        const foundTasks = tasks.filter(t => 
            t.text.toLowerCase().includes(query) || 
            (t.tag && t.tag.toLowerCase().includes(query))
        );
        
        if (foundTasks.length > 0) {
            foundTasks.forEach(t => {
                const li = document.createElement('li');
                const displayDate = formatDateToDisplay(t.date);
                const timeInfo = t.elapsedTime ? ` - Tiempo: ${formatTime(t.elapsedTime)}` : '';
                
                li.innerText = `TAREA: ${t.text} (${t.tag || 'Sin etiqueta'}) - ${displayDate}${timeInfo}`;
                li.className = t.done ? 'completed' : '';
                results.appendChild(li);
            });
        } else {
            results.innerHTML = '<p>No se encontraron tareas con ese criterio.</p>';
        }
    }
    
    const searchInput = document.getElementById("searchInput");
    const searchResults = document.getElementById("searchResults");
    const clearSearchBtn = document.getElementById("clearSearchBtn");
    const searchBtn = document.getElementById('searchBtn');

    searchBtn.addEventListener('click', searchItems);

    clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        searchResults.innerHTML = "";
        renderTasks();
        renderCalendar();
    });

    // ----------------------------------------------------------------------
    // ‚öôÔ∏è INICIALIZACI√ìN DEL DOM ‚öôÔ∏è
    // ----------------------------------------------------------------------

    function initializeDateInput() {
        const todayStr = getTodayDateStrForInput();
        const taskDateInput = document.getElementById('taskDate');
        
        // 1. Establece el valor por defecto a la fecha actual
        taskDateInput.value = todayStr;
        
        // 2. Establece la fecha m√≠nima seleccionable a la fecha actual
        taskDateInput.min = todayStr;
    }

    // Asegura que el input de fecha est√© configurado al cargar el script
    initializeDateInput();

</script>
</body>
</html>
